{"meta":{"title":"Go for it! Just do it!","subtitle":"","description":"zmq的个人博客","author":"zmq","url":"http://zmq.cool","root":"/zmq-git.github.io/"},"pages":[{"title":"about","date":"2021-03-23T02:31:03.000Z","updated":"2021-03-23T02:31:03.374Z","comments":true,"path":"about/index.html","permalink":"http://zmq.cool/about/index.html","excerpt":"","text":""},{"title":"category","date":"2021-03-20T05:32:08.000Z","updated":"2021-03-20T07:08:41.960Z","comments":true,"path":"category/index.html","permalink":"http://zmq.cool/category/index.html","excerpt":"","text":""},{"title":"tag","date":"2021-03-20T05:32:08.000Z","updated":"2021-03-20T07:08:28.378Z","comments":true,"path":"tag/index.html","permalink":"http://zmq.cool/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql-事务","slug":"mysql-事务","date":"2021-03-21T11:54:23.994Z","updated":"2021-03-21T12:13:46.022Z","comments":true,"path":"2021/03/21/mysql-事务/","link":"","permalink":"http://zmq.cool/2021/03/21/mysql-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"什么是事务？事务是逻辑上的一组操作，要么都执行，要么都不执行。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 事务的四大特性(ACID) 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 并发事务带来哪些问题在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复读和幻读区别： 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。 事务隔离级别有哪些?MySQL的默认隔离级别是?SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 隔离级别 脏读 不可重复读 幻影读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × 隔离级别越低，事务请求的锁越少；MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看；大部分数据库的隔离级别都是READ-COMMITTED(读取已提交)，InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://zmq.cool/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zmq.cool/tags/mysql/"}]},{"title":"Redis集群","slug":"搭建Redis集群","date":"2021-03-20T07:33:08.016Z","updated":"2021-03-21T12:20:53.266Z","comments":true,"path":"2021/03/20/搭建Redis集群/","link":"","permalink":"http://zmq.cool/2021/03/20/%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/","excerpt":"","text":"redis集群简介 是一个开源的key value存储系统，受到了广大互联网公司的青睐。redis3.0版本之前只支持单例模式，在3.0版本及以后才支持集群； redis集群采用P2P模式，是完全去中心化的，不存在中心节点或者代理节点； redis集群是没有统一的入口的，客户端（client）连接集群的时候连接集群中的任意节点（node）即可，集群内部的节点是相互通信的（PING-PONG机制），每个节点都是一个redis实例； 为了实现集群的高可用，即判断节点是否健康（能否正常使用），redis-cluster有这么一个投票容错机制：如果集群中超过半数的节点投票认为某个节点挂了，那么这个节点就挂了（fail）。这是判断节点是否挂了的方法； 那么如何判断集群是否挂了呢? -&gt; 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。这是判断集群是否挂了的方法； 那么为什么任意一个节点挂了（没有从节点）这个集群就挂了呢？ -&gt; 因为集群内置了16384个slot（哈希槽），并且把所有的物理节点映射到了这16384[0-16383]个slot上，或者说把这些slot均等的分配给了各个节点。当需要在Redis集群存放一个数据（key-value）时，redis会先对这个key进行crc16算法，然后得到一个结果。再把这个结果对16384进行求余，这个余数会对应[0-16383]其中一个槽，进而决定key-value存储到哪个节点中。所以一旦某个节点挂了，该节点对应的slot就无法使用，那么就会导致集群无法正常工作。 综上所述，每个Redis集群理论上最多可以有16384个节点。 Redis集群的搭建 Linux版本：CentOS7.6 x64Redis版本：6.0.9","categories":[{"name":"redis","slug":"redis","permalink":"http://zmq.cool/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zmq.cool/tags/redis/"}]},{"title":"linux系统搭建Redis","slug":"linux系统搭建Redis","date":"2021-03-19T13:59:19.591Z","updated":"2021-03-21T12:26:00.509Z","comments":true,"path":"2021/03/19/linux系统搭建Redis/","link":"","permalink":"http://zmq.cool/2021/03/19/linux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BARedis/","excerpt":"","text":"Redis简介​ redis是一个基于key-value形式进行存储的内存型数据库 ​ 优点：效率高 理论值：每秒10k数据读取 ​ Redis是一个NoSql数据库,将其作为缓存工具使用（把某些使用频率较高的内容存储到Redis中) Redis持久化策略rdb​ 默认的持久化策略；每隔一段时间后把内存中数据持久化到dump.rdb文件中 ​ 缺点：数据过于集中,可能导致最后的数据没有持久化到dump.rdb中（可以使用save或BGSAVE命令手动持久化） aof​ 监听Redis的日志文件，监听如果发生了修改，删除，新增命令，立即根据这条命令把数据持久化 ​ 缺点：效率降低 Redis数据类型​ String 、Hash、 List 、 Set、 SortedSet Redis安装 Linux版本：CentOS7.6 x64Redis版本：6.0.9 安装gcc12345678910111213141516# 查看gcc版本是否在9.3以上，centos7.6默认安装4.8.5gcc -v# 升级gcc到9.3及以上,如下：升级到gcc 9.3：yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl enable devtoolset-9 bash需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用gcc 9.3的话：echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile这样退出shell重新打开就是新版的gcc了以下其他版本同理，修改devtoolset版本号即可。 解压编译将下载的压缩包上传到/usr/local目录下，解压压缩包 1tar zxf redis-6.0.9.tar.gz 进入解压后的目录进行编译 12cd redis-6.0.9make 指定目录安装 1make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis 至此，Redis安装完毕。 启动Redis前台启动12cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-server ps: 这种启动方式不能关闭控制台，否则Redis就直接退出了 后台启动从 redis 的解压目录中复制 redis.conf 到 redis 的安装目录 1cp &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F; 修改 redis.conf 文件，把 daemonize no 改为 daemonize yes ps: daemonize是用来指定redis是否要用守护线程的方式启动。 123456##启动命令：.&#x2F;redis-server redis.conf##停止命令.&#x2F;redis-cli shutdown##查看服务是否启动成功ps aux |grep redis 远程客户端连接Redis修改redis安装目录下的redis.conf文件，将bind:127.0.0.1注掉（使所有的ip都能访问到redis server） 打开防火墙：修改 /etc/sysconfig下面的iptables文件，添加 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT 最后运行 systemctl restart iptables 命令重启即可。 Redis密码设置如果需要设置Redis的密码，编辑redis.conf文件，找到requirepass，将注释放开并且更改密码。 1234###连接：.&#x2F;redis-cli -a 你的密码###停止：.&#x2F;redis-cli -a 你的密码 shutdown","categories":[{"name":"redis","slug":"redis","permalink":"http://zmq.cool/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zmq.cool/tags/redis/"}]}],"categories":[{"name":"mysql","slug":"mysql","permalink":"http://zmq.cool/categories/mysql/"},{"name":"redis","slug":"redis","permalink":"http://zmq.cool/categories/redis/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zmq.cool/tags/mysql/"},{"name":"redis","slug":"redis","permalink":"http://zmq.cool/tags/redis/"}]}