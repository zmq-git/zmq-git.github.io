{"meta":{"title":"Go for it! Just do it!","subtitle":"","description":"zmq的个人博客","author":"zmq","url":"https://zmq.cool","root":"/zmq-git.github.io/"},"pages":[{"title":"about","date":"2021-03-23T02:31:03.000Z","updated":"2021-03-28T13:35:46.017Z","comments":true,"path":"about/index.html","permalink":"https://zmq.cool/about/index.html","excerpt":"","text":"1.掌握 Java 基础知识（可以看《Java 核⼼技术卷1》或者《Head First Java》 2.掌握多线程的简单实⽤（推荐《Java并发编程之美》或者《实战Java⾼并发程序设计》）。 3.学习前端基础(HTML、CSS、JavaScript),当然BootStrap、VUE等等前端框架你也可以了 解⼀下。 4.学习MySQL 的基本使⽤，基本的增删改查，SQL命令，索引、存储过程这些都学⼀下吧！ 5.建议学习J2ee框架之前可以提前花半天时间学习⼀下Maven的使⽤。（到处找Jar包，下载 Jar包是真的麻烦费事，使⽤Maven可以为你省很多事情） 6.学习Spring、SpringMVC、Hibernate、Mybatis 等框架的使⽤，(可 选)熟悉 Spring 原理（⼤⼚⾯试必备），然后很有必要学习⼀下SpringBoot。 7.学习Linux的基本使⽤(常⻅命令、基本概念) 8.学习Dubbo、Zookeeper、常⻅的消息队列（⽐如ActiveMq、RabbitMQ）的使⽤ 9.可以学习⼀下NIO和Netty 10.JVM 的⼀些知识也是必学的（Java内存区域、虚拟机垃圾算法、虚 拟垃圾收集器、JVM内存管理）"},{"title":"category","date":"2021-03-20T05:32:08.000Z","updated":"2021-03-20T07:08:41.960Z","comments":true,"path":"category/index.html","permalink":"https://zmq.cool/category/index.html","excerpt":"","text":""},{"title":"tag","date":"2021-03-20T05:32:08.000Z","updated":"2021-03-20T07:08:28.378Z","comments":true,"path":"tag/index.html","permalink":"https://zmq.cool/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"mybatis的缓存机制","slug":"mybatis的缓存机制","date":"2021-04-04T13:48:50.000Z","updated":"2021-04-05T03:00:00.757Z","comments":true,"path":"2021/04/04/mybatis的缓存机制/","link":"","permalink":"https://zmq.cool/2021/04/04/mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"mybatis分一级缓存和二级缓存，如下图，是mybatis一级缓存和二级缓存的区别图解： 一级缓存Mybatis的一级缓存是默认开启的，作用域是同一个SqlSession，当参数和SQL完全相同的情况下，使用同一个SqlSession对象调用同一个Mapper方法，当第1次执行SQL语句后，MyBatis会自动将其放在缓存中，后续再次查询时，如果没有声明需要刷新，且缓存没有超时，会直接取出此前缓存的数据，而不会再次发送SQL到数据库。，从而提高查询效率。当 Session flush 或 close 之后，该Session中的所有 Cache 就将清空。 这里使用同一个sqlSession对象去查询两次，并且比较查询出来的对象是否是同一个，即比较内存地址。 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception&#123; InputStream inputStream &#x3D; null; SqlSession sqlSession &#x3D; null; try &#123; inputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); sqlSession &#x3D; sqlSessionFactory.openSession(); UserDao userDao &#x3D; sqlSession.getMapper(UserDao.class); System.out.println(&quot;第一次查询&quot;); List&lt;User&gt; user1 &#x3D; userDao.getAllUser(); for (User user : user1) &#123; System.out.println(user); &#125; System.out.println(&quot;第二次查询&quot;); List&lt;User&gt; user2 &#x3D; userDao.getAllUser(); for (User user : user2) &#123; System.out.println(user); &#125; System.out.println(&quot;是同一个对象:&quot;+(user1&#x3D;&#x3D;user2)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource(sqlSession, inputStream); &#125; &#125; 从下图可以看出，第一次查询打印了sql,说明第一次查询去数据库中查出来了数据，第二次查询没有去数据库中查询数据，而是直接从缓存中获取。并且两次查询的结果是同一个对象。 二级缓存Mybatis二级缓存的作用域是同一个Mapper，二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。所以二级存储也称之为namespace缓存！二级缓存默认也是开启的，可以修改配置文件mybatis-config.xml设置&lt;setting name=”cacheEnabled”value=”true”/&gt;，默认是true，即所说的默认是开启的。 ps：MyBatis默认实现的一二级缓存是使用HashMap存储的。只有当sqlSession关闭之后，该sqlSession的查询结果才会存入二级缓存中。 在开启二级缓存的情况下： 在同一个Mapper二级缓存里面，执行多次sql语句的情况是：首先查找二级缓存里面是否有数据，如果没有就找一级缓存，再没有，才会查找数据库。 在二级缓存没有开启的情况下： 查找数据的顺序是：查看一级缓存里面是否能够找到，找不到就在数据库里面找！！ 二级缓存的使用1.修改配置文件mybatis-config.xml加入&lt;setting name=”cacheEnabled”value=”true”/&gt;，由于默认是true，所以不添加也可以。 2.在mapper.xml中开启二缓存，mapper.xml下的sql执行完成会存储到它的缓存区,如： 3.对应的pojo实现序列化(implements Serializable)。 这里使用两个不同的sqlSession去获取mapper对象，调用同一个查询方法： 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; InputStream inputStream &#x3D; null; SqlSession sqlSession1 &#x3D; null; SqlSession sqlSession2 &#x3D; null; try &#123; inputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); sqlSession1 &#x3D; sqlSessionFactory.openSession(); sqlSession2 &#x3D; sqlSessionFactory.openSession(); UserDao userDao1 &#x3D; sqlSession1.getMapper(UserDao.class); UserDao userDao2 &#x3D; sqlSession2.getMapper(UserDao.class); System.out.println(&quot;第一次查询&quot;); List&lt;User&gt; user1 &#x3D; userDao1.getAllUser(); for (User user : user1) &#123; System.out.println(user); &#125; System.out.println(&quot;第二次查询&quot;); List&lt;User&gt; user2 &#x3D; userDao2.getAllUser(); for (User user : user2) &#123; System.out.println(user); &#125; System.out.println(&quot;是同一个对象:&quot;+(user1&#x3D;&#x3D;user2)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource(inputStream,sqlSession1,sqlSession2); &#125; &#125; 但是发现第二次查询还是去查询的数据库，并没有走缓存，因为第一个sqlSession1并没有关闭，查询结果并不会被序列化并保存到二级缓存，这里其实先去查询了二级缓存 Cache Hit Ratio [com.test.dao.UserDao]: 0.0），表示命中次数与查询次数的比值。 关闭sqlSession1，sqlSession1.close()，继续查看日志，可以看到第二次查询命中了二级缓存，命中一次/查询两次=0.5。 但是我们可以发现两次查询出来的对象不是同一个，难道不是查的缓存吗，其实是cache中的readOnly属性在启作用： readOnly 为只读属性， 默认为 false false: 可读写， 在创建对象时， 会通过反序列化得到缓存对象的拷贝。 因此在速度上会相对慢一点， 但重在安全。 true: 只读， 只读的缓存会给所有调用者返回缓存对象的相同实例。 因此性能很好， 但如果修改了对象， 有可能会导致程序出问题。 注意事项由于在更新时会刷新缓存， 因此需要注意使用场合：查询频率很高， 更新频率很低时使用， 即经常使用 select, 相对较少使用delete, insert, update。 缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响。但刷新缓存是刷新整个 namespace 的缓存， 也就是你 update 了一个， 则整个缓存都刷新了。 一二级缓存都可能会导致脏读（缓存不一样），二级缓存中，最好在 「只有单表操作」 的表的 namespace 使用缓存， 而且对该表的操作都在这个 namespace 中。 否则可能会出现数据不一致的情况（脏读）。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zmq.cool/tags/mybatis/"}]},{"title":"Java中的String类","slug":"Java中的String类","date":"2021-03-31T06:11:30.000Z","updated":"2021-03-31T07:52:33.782Z","comments":true,"path":"2021/03/31/Java中的String类/","link":"","permalink":"https://zmq.cool/2021/03/31/Java%E4%B8%AD%E7%9A%84String%E7%B1%BB/","excerpt":"","text":"String可变吗？1234567public class Test1 &#123; public static void main(String[] args) &#123; String str &#x3D; &quot;0000&quot;; str &#x3D; &quot;1111&quot;; System.out.println(str); &#125;&#125; ​ 我们都知道Java中的String是不可变的, 那上面段代码应该输出：0000, 这样才和不变性吻合。可实际上是这样吗, 并不是, 事实上输出的是：1111。那这是不是和不变性的说法冲突了呢？我们先来看下面一段话： 其实在JVM的运行中，会单独给一块地分给String。我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化： 使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。 ​ 在上面的代码中，首先会先去JVM的常量池中查找有没有”0000”这个对象，如果找到了，直接将该对象的引用地址赋值给str。找不到的话会创建一个对象，并且将其引用赋给str, str = “1111”也是同理。所以str实际上保存的是字符串在内存中的地址，str只是一个引用变量，真正不可变的是”0000”。 String为什么是不可变的?我们来看看他的源码 123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; &#x2F;** The value is used for character storage. *&#x2F; private final char value[]; public String(String original) &#123; this.value &#x3D; original.value; this.hash &#x3D; original.hash; &#125; 从上面的这段源码中可以看出三点： String 类是final修饰 String存储内容使用的是char数组 char数组是final修饰 所以，实际上我们在创建一个String对象的时候，内容被保存在了char数组中，而由于char数组被final修饰，所以不可变。 1234567891011public class Test1 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;String str &#x3D; &quot;0000&quot;;相当于 char[] value &#x3D; new char[]&#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;; String str &#x3D; new String(value); &#x2F;&#x2F;str &#x3D; &quot;1111&quot;; char[] value1 &#x3D; new char[]&#123;&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;&#125;; str &#x3D; new String(value1); System.out.println(str); &#125;&#125; 这里复习一下，final有啥用 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 当final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。） 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化。如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。另外final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，（在申明的时候给其赋值，否则必须在其类的所有构造方法中都要为其赋值） 再来看一个String的案例1234567891011public class Test1 &#123; public static void main(String[] args) &#123; String str &#x3D; &quot;Hello World&quot;; System.out.println(str); str.substring(0,str.indexOf(&quot;W&quot;)); System.out.println(str); System.out.println(str.substring(0,str.indexOf(&quot;W&quot;))); &#125;&#125; 输出： 无论是concat、replace、substring还是trim方法的操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。这里踩过几个坑。。。 得出两个结论： String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何变化性的操作都会生成新的对象。 String对象每次有变化性操作的时候，都会重新new一个String对象（这里指的是有变化的情况）。 finally, 探究下String s = new String(“111”)会创建几个对象？接触Java后都知道可以new一个对象。所以 String s = new String(“111”);就是创建一个对象然后把对象引用地址赋给变量s。但是这里有个特殊点，那就是（“111”）,这里会先去JVM里的那块常量池里找找有没有这个对象，找到了直接将引用地址赋给String的构造方法。找不到就创建一个对象然后把引用地址给String的有参构造方法。 所以答案是: ​ 如果常量池中存在，则只需创建一个对象，否则需要创建两个对象。","categories":[{"name":"Java","slug":"Java","permalink":"https://zmq.cool/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Springboot+Vue之DatePicker","slug":"Springboot+Vue之DatePicker","date":"2021-03-26T03:05:54.000Z","updated":"2021-03-26T09:03:07.261Z","comments":true,"path":"2021/03/26/Springboot+Vue之DatePicker/","link":"","permalink":"https://zmq.cool/2021/03/26/Springboot+Vue%E4%B9%8BDatePicker/","excerpt":"","text":"最近在开发一个Springboot+Vue项目中，使用到Ant Design Vue中的日期选择框组件’DatePicker’，发现向后台提交数据时报错：Failed to convert property value of type ‘java.lang.String’ to required ‘Date’ 一开始想到的是在实体类属性上添加@DateTimeFormat注解，@DatetimeFormat是将String转换成Date，一般前台给后台传值时用 12@DateTimeFormat(pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;)private Date startDate; 发现还是报错： Failed to convert from type [java.lang.String] to type[@org.springframework.format.annotation.DateTimeFormat java.util.Date] for value ‘“2021-03-10T06:09:01.563Z” 表示无法将字符串转换为Date类型，查看日志发现前台传过来的格式并不是我在@DateTimeFormat 注解上pattern中的规定的格式 “2021-03-10T06:09:01.563Z”，而@DateTimeFormat 注解只能解析与它定义的格式相同的字符串，所以导致报错。在前台通过F12打印出日期，发现最终提交到后台的时间格式为Moment()，并不是String，解决办法： 1.引入moment 1import moment from &#39;moment&#39; 2.修改vue代码，更改传入后台的Date的时间格式 1moment(date).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);","categories":[{"name":"Web","slug":"Web","permalink":"https://zmq.cool/categories/Web/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://zmq.cool/tags/Code/"}]},{"title":"浅谈hashCode()和equals()","slug":"hashCode-和equals","date":"2021-03-23T08:42:04.000Z","updated":"2021-03-31T07:44:56.106Z","comments":true,"path":"2021/03/23/hashCode-和equals/","link":"","permalink":"https://zmq.cool/2021/03/23/hashCode-%E5%92%8Cequals/","excerpt":"","text":"equals()介绍：equals() 的作用是 用来判断两个对象是否相等。 equals() 定义在JDK的Object.java中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下： 123public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj);&#125; 既然Object.java中定义了equals()方法，这就意味着所有的Java类都实现了equals()方法，所有的类都可以通过equals()去比较两个对象是否相等。 但是，我们已经说过，使用默认的“**equals()”方法，等价于“==**”方法。因此，我们通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。 下面根据“类是否覆盖equals()方法”，将它分为2类。(01) 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。(02) 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。 java对equals()的要求，有以下几点： 对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。 反射性：x.equals(x)必须返回是”true”。 类推性：如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。 一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。 非空性，x.equals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。 hashCode()介绍:hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 1public native int hashCode();Copy to clipboardErrorCopied 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode？我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 为什么重写 equals 时必须重写 hashCode 方法？如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode。 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。","categories":[{"name":"Java","slug":"Java","permalink":"https://zmq.cool/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Mysql之事务","slug":"mysql之事务","date":"2021-03-21T11:54:23.994Z","updated":"2021-03-31T07:54:36.771Z","comments":true,"path":"2021/03/21/mysql之事务/","link":"","permalink":"https://zmq.cool/2021/03/21/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"什么是事务？事务是逻辑上的一组操作，要么都执行，要么都不执行。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 事务的四大特性(ACID) 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 并发事务带来哪些问题在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复读和幻读区别： 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。 事务隔离级别有哪些?MySQL的默认隔离级别是?SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 隔离级别 脏读 不可重复读 幻影读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × 隔离级别越低，事务请求的锁越少；MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看；大部分数据库的隔离级别都是READ-COMMITTED(读取已提交)，InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zmq.cool/categories/Mysql/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Redis集群","slug":"搭建Redis集群","date":"2021-03-20T07:33:08.016Z","updated":"2021-04-03T13:19:12.078Z","comments":true,"path":"2021/03/20/搭建Redis集群/","link":"","permalink":"https://zmq.cool/2021/03/20/%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/","excerpt":"","text":"redis集群简介 是一个开源的key value存储系统，受到了广大互联网公司的青睐。redis3.0版本之前只支持单例模式，在3.0版本及以后才支持集群； redis集群采用P2P模式，是完全去中心化的，不存在中心节点或者代理节点； redis集群是没有统一的入口的，客户端（client）连接集群的时候连接集群中的任意节点（node）即可，集群内部的节点是相互通信的（PING-PONG机制），每个节点都是一个redis实例； 为了实现集群的高可用，即判断节点是否健康（能否正常使用），redis-cluster有这么一个投票容错机制：如果集群中超过半数的节点投票认为某个节点挂了，那么这个节点就挂了（fail）。这是判断节点是否挂了的方法； 那么如何判断集群是否挂了呢? -&gt; 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。这是判断集群是否挂了的方法； 那么为什么任意一个节点挂了（没有从节点）这个集群就挂了呢？ -&gt; 因为集群内置了16384个slot（哈希槽），并且把所有的物理节点映射到了这16384[0-16383]个slot上，或者说把这些slot均等的分配给了各个节点。当需要在Redis集群存放一个数据（key-value）时，redis会先对这个key进行crc16算法，然后得到一个结果。再把这个结果对16384进行求余，这个余数会对应[0-16383]其中一个槽，进而决定key-value存储到哪个节点中。所以一旦某个节点挂了，该节点对应的slot就无法使用，那么就会导致集群无法正常工作。 综上所述，每个Redis集群理论上最多可以有16384个节点。 Redis集群的搭建 Linux版本：CentOS7.6 x64Redis版本：6.0.9 所需环境Redis集群至少需要3个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以2个节点无法构成集群。要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，所以Redis集群至少需要6台服务器。这里搭建的是伪分布式集群，即一台服务器虚拟运行6个redis实例，修改端口号为（7001-7006）。 搭建步骤1.在/usr/local下创建redis-cluster目录，用来存放集群节点 2.将redis安装目录中bin目录下面的所有文件拷贝一份到/usr/local/redis-cluster/redis1目录下 1cp -r &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1 3.删除redis1目录下的快照文件dump.rdb，并且修改该目录下的redis.conf文件，具体修改两处地方：一是端口号修改为7001: 二是开启集群创建模式,cluster-enabled yes 的注释打开: 4.将redis1下的文件复制五份到redis2-redis6中 12345cp -r &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis2cp -r &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis3cp -r &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis4cp -r &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis5cp -r &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis1&#x2F; &#x2F;usr&#x2F;local&#x2F;redis-cluster&#x2F;redis6 创建完后，如图所示: 5.分别修改redis2-redis6下的redis.conf文件端口号为7002-7006 6.启动所有的redis节点，这里创建一个shell脚本 touch start-all.sh ，用于批量启动所有的redis节点，文件内容如下： 123456789101112131415161718cd redis1.&#x2F;redis-server redis.confcd ..cd redis2.&#x2F;redis-server redis.confcd ..cd redis3.&#x2F;redis-server redis.confcd ..cd redis4.&#x2F;redis-server redis.confcd ..cd redis5.&#x2F;redis-server redis.confcd ..cd redis6.&#x2F;redis-server redis.confcd .. 创建好启动脚本文件之后，需要修改该脚本的权限，使之能够执行，指令如下： 1chmod +x start-all.sh 执行shell脚本： 1.&#x2F;start-all.sh 6个redis节点是否启动成功，可以使用 ps aux|grep redis 命令查看： 7.执行集群相关命令，指定redis集群节点的ip和端口号，进入到任意一个redis的bin目录下，都可执行。 1.&#x2F;redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 ps:上面命令中的1代表主节点和从节点的比值是多少，我们是3主3从，所以这个比值是1，而且前三个一定是主节点，redis就是这样规定的。 执行效果如图： 至此，Redi集群搭建成功！上面这个图显示了每个节点所分配的slots（哈希槽），这里总共6个节点，其中3个是从节点，所以3个主节点分别映射了0-5460、5461-10922、10933-16383solts。 最后连接集群节点，连接任意一个即可： 1.&#x2F;redis-cli -p 7001 -c ps:一定要加上-c，不然节点之间是无法自动跳转的！如下图可以看到，存储的数据（key-value）是均匀分配到不同的节点的：","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zmq.cool/categories/Redis/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zmq.cool/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"linux搭建Redis教程","slug":"linux系统搭建Redis","date":"2021-03-19T13:59:19.591Z","updated":"2021-03-31T07:51:15.412Z","comments":true,"path":"2021/03/19/linux系统搭建Redis/","link":"","permalink":"https://zmq.cool/2021/03/19/linux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BARedis/","excerpt":"","text":"Redis简介​ redis是一个基于key-value形式进行存储的内存型数据库 ​ 优点：效率高 理论值：每秒10k数据读取 ​ Redis是一个NoSql数据库,将其作为缓存工具使用（把某些使用频率较高的内容存储到Redis中) Redis持久化策略rdb​ 默认的持久化策略；每隔一段时间后把内存中数据持久化到dump.rdb文件中 ​ 缺点：数据过于集中,可能导致最后的数据没有持久化到dump.rdb中（可以使用save或BGSAVE命令手动持久化） aof​ 监听Redis的日志文件，监听如果发生了修改，删除，新增命令，立即根据这条命令把数据持久化 ​ 缺点：效率降低 Redis数据类型​ String 、Hash、 List 、 Set、 SortedSet Redis安装 Linux版本：CentOS7.6 x64Redis版本：6.0.9 安装gcc12345678910111213141516# 查看gcc版本是否在9.3以上，centos7.6默认安装4.8.5gcc -v# 升级gcc到9.3及以上,如下：升级到gcc 9.3：yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl enable devtoolset-9 bash需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用gcc 9.3的话：echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile这样退出shell重新打开就是新版的gcc了以下其他版本同理，修改devtoolset版本号即可。 解压编译将下载的压缩包上传到/usr/local目录下，解压压缩包 1tar zxf redis-6.0.9.tar.gz 进入解压后的目录进行编译 12cd redis-6.0.9make 指定目录安装 1make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis 至此，Redis安装完毕。 启动Redis前台启动12cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;.&#x2F;redis-server ps: 这种启动方式不能关闭控制台，否则Redis就直接退出了 后台启动从 redis 的解压目录中复制 redis.conf 到 redis 的安装目录 1cp &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F; 修改 redis.conf 文件，把 daemonize no 改为 daemonize yes ps: daemonize是用来指定redis是否要用守护线程的方式启动。 123456##启动命令：.&#x2F;redis-server redis.conf##停止命令.&#x2F;redis-cli shutdown##查看服务是否启动成功ps aux |grep redis 远程客户端连接Redis修改redis安装目录下的redis.conf文件，将bind:127.0.0.1注掉（使所有的ip都能访问到redis server） 打开防火墙：修改 /etc/sysconfig下面的iptables文件，添加 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT 最后运行 systemctl restart iptables 命令重启即可。 Redis密码设置如果需要设置Redis的密码，编辑redis.conf文件，找到requirepass，将注释放开并且更改密码。 1234###连接：.&#x2F;redis-cli -a 你的密码###停止：.&#x2F;redis-cli -a 你的密码 shutdown","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zmq.cool/categories/Redis/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zmq.cool/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://zmq.cool/categories/Java/"},{"name":"Web","slug":"Web","permalink":"https://zmq.cool/categories/Web/"},{"name":"Mysql","slug":"Mysql","permalink":"https://zmq.cool/categories/Mysql/"},{"name":"Redis","slug":"Redis","permalink":"https://zmq.cool/categories/Redis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zmq.cool/tags/mybatis/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://zmq.cool/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Code","slug":"Code","permalink":"https://zmq.cool/tags/Code/"},{"name":"教程","slug":"教程","permalink":"https://zmq.cool/tags/%E6%95%99%E7%A8%8B/"}]}